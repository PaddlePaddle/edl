# 碎片化资源估算框架设计

## 现状分析

目前我们在使用集群的时候将集群看做是一个大机器来进行资源分配，但实际情况是，集群和大机器还是会有本质上的区别，这个区别在于，如果没有合理的调度 & 再调度能力的支撑，集群上的机器很容易会生成碎片资源，从而导致在外界看来，集群还有相当部分的资源，然而对应的大任务无法被调度到集群上。


## 目标

* 通过添加一种框架，达到对于集群中各个机器的资源整理，从而对于一些大任务，能在进入调度器之前进行拦截评估，对于无法调度的任务，执行对应的策略，使其在被调度之前就能被优先处理。

* 后续将引入rescheduler的能力，对于集群碎片进行定期优化处理，并配合相应的调度策略，减少集群的碎片资源。

## 解决方案

### 所需能力

* 探测cluster下的剩余资源
* 计算得到所需资源的任务的最大副本数量
* 将计算所得的数量与请求的副本数量进行比较，如果小于请求数量，则拦截任务提交

### 所需框架

* 估算器来对集群上所有机器的碎片化资源进行估算，得到能分配任务的最大值
* 拦截器来拦截quota资源看起来足够，但是事实上已经没有足够的完整资源来运行相应副本数量的任务

### API

api包括pod的spec信息，namespace信息

```
请求路径：/v1/max-pod-estimator
请求方法：GET
功能说明：得到该pod spec能在集群运行的最大副本数
请求参数说明：
 - 类型： application/json; charset=utf-8
 - 字段说明：
     - podSpec: string
     - namespace：string
返回说明：
 - 类型： application/json; charset=utf-8
 - 字段说明：
 	 - code: integer
 	 - msg: string
 	 - data: string
```

```
请求路径：/v1/pod-inceptor
请求方法：GET
功能说明：得到集群是否有足够的quota来接受该pod spec
请求参数说明：
 - 类型： application/json; charset=utf-8
 - 字段说明：
     - podSpec: string
     - namespace：string
返回说明：
 - 类型： application/json; charset=utf-8
 - 字段说明：
 	 - code: integer
 	 - msg: string
 	 - data: string
```

### 轮询估算 vs 实时计算 tradeoff

对于该框架而言，我们不需要在每一次有任务提交上来的时候，都去检查每一个资源的使用情况，因为即使这样，还是有概率出现在实际调度的时候，有资源不足情况的发生，所以可以采用轮询集群状态并缓存的方式来对各个机器资源进行估算。

### 测试用例

待补充

### 后续

* 与rescheduler结合

* 与优先级调度结合

